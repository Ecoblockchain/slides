{
  "name": "hyperlog",
  "version": "4.6.0",
  "description": "Merkle DAG that replicates based on scuttlebutt logs and causal linking",
  "main": "index.js",
  "dependencies": {
    "after-all": "^2.0.2",
    "bitfield": "^1.1.2",
    "brfs": "^1.4.0",
    "cuid": "^1.2.5",
    "debug": "^2.2.0",
    "duplexify": "^3.4.2",
    "framed-hash": "^1.1.0",
    "from2": "^2.1.0",
    "length-prefixed-stream": "^1.3.0",
    "level-enumerate": "^1.0.1",
    "level-logs": "^1.1.0",
    "lexicographic-integer": "^1.1.0",
    "mutexify": "^1.1.0",
    "protocol-buffers": "^3.1.2",
    "pump": "^1.0.0",
    "stream-collector": "^1.0.1",
    "through2": "^2.0.0"
  },
  "devDependencies": {
    "memdb": "^1.0.1",
    "standard": "^4.5.4",
    "tape": "^4.0.0"
  },
  "browserify": {
    "transform": [
      "brfs"
    ]
  },
  "scripts": {
    "test": "standard && tape test/*"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mafintosh/hyperlog.git"
  },
  "author": {
    "name": "Mathias Buus",
    "url": "@mafintosh"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mafintosh/hyperlog/issues"
  },
  "homepage": "https://github.com/mafintosh/hyperlog",
  "readme": "# hyperlog\n\n[Merkle DAG](https://github.com/jbenet/random-ideas/issues/20) that replicates based on scuttlebutt logs and causal linking\n\n```\nnpm install hyperlog\n```\n\n[![build status](http://img.shields.io/travis/mafintosh/hyperlog.svg?style=flat)](http://travis-ci.org/mafintosh/hyperlog)\n![dat](http://img.shields.io/badge/Development%20sponsored%20by-dat-green.svg?style=flat)\n\n``` js\nvar hyperlog = require('hyperlog')\n\nvar log = hyperlog(db) // where db is a levelup instance\n\n// add a node with value 'hello' and no links\nlog.add(null, 'hello', function(err, node) {\n  console.log('inserted node', node)\n\n  // insert 'world' with a link back to the above node\n  log.add([node.key], 'world', function(err, node) {\n    console.log('inserted new node', node)\n  })\n})\n```\n\n## Replicate graph\n\nTo replicate this log with another one simply use `log.replicate()` and pipe it together with a replication stream from another log.\n\n``` js\nvar l1 = hyperlog(db1)\nvar l2 = hyperlog(db2)\n\nvar s1 = l1.replicate()\nvar s2 = l2.replicate()\n\ns1.pipe(s2).pipe(s1)\n\ns1.on('end', function() {\n  console.log('replication ended')\n})\n```\n\nA detailed write-up on how this replication protocol works will be added to this repo in the near\nfuture. For now see the source code.\n\n## API\n\n#### `log = hyperlog(db, [options])`\n\nCreate a new log instance. Options include:\n\n``` js\n{\n  id: 'a-globally-unique-peer-id',\n  valueEncoding: 'a levelup-style encoding property' // example: 'json'\n}\n```\n\nYou can also pass in a `identity` and a `sign` and `verify` function\nwhich can be used to create a signed log\n\n``` js\n{\n  identity: aPublicKeyBuffer, // will be added to all nodes you insert\n  sign: function (node, cb) {\n    // will be called with all nodes you add\n    var signatureBuffer = someCrypto.sign(node.key, mySecretKey)\n    cb(null, signatureBuffer)\n  },\n  verify: function (node, cb) {\n    // will be called with all nodes you receive\n    if (!node.signature) return cb(null, false)\n    cb(null, someCrypto.verify(node.key, node.signature. node.identity))\n  }\n}\n```\n\n#### `log.add(links, value, opts={}, [cb])`\n\nAdd a new node to the graph. `links` should be an array of node keys that this node links to.\nIf it doesn't link to any nodes use `null` or an empty array. `value` is the value that you want to store\nin the node. This should be a string or a buffer. The callback is called with the inserted node:\n\n``` js\nlog.add([link], value, function(err, node) {\n  // node looks like this\n  {\n    change: ... // the change number for this node in the local log\n    key:   ... // the hash of the node. this is also the key of the node\n    value:  ... // the value (as a buffer) you inserted\n    log:    ... // the peer log this node was appended to\n    seq:    ... // the peer log seq number\n    links: ['hash-of-link-1', ...]\n  }\n})\n```\n\nOptionally supply an `opts.valueEncoding`.\n\n#### `log.append(value, opts={}, [cb])`\n\nAdd a value that links all the current heads.\n\nOptionally supply an `opts.valueEncoding`.\n\n#### `log.get(hash, opts={}, cb)`\n\nLookup a node by its hash. Returns a node similar to `.add` above.\n\nOptionally supply an `opts.valueEncoding`.\n\n#### `log.heads(opts={}, cb)`\n\nGet the heads of the graph as a list. A head is node that no other node\nlinks to.\n\n``` js\nlog.heads(function(err, heads) {\n  console.log(heads) // prints an array of nodes\n})\n```\n\nThe method also returns a stream of heads which is useful\nif, for some reason, your graph has A LOT of heads\n\n``` js\nvar headsStream = log.heads()\n\nheadsStream.on('data', function(node) {\n  console.log('head:', node)\n})\n\nheadsStream.on('end', function() {\n  console.log('(no more heads)')\n})\n```\n\nOptionally supply an `opts.valueEncoding`.\n\n#### `changesStream = log.createReadStream([options])`\n\nTail the changes feed from the log. Everytime you add a node to the graph\nthe changes feed is updated with that node.\n\n``` js\nvar changesStream = log.createReadStream({live:true})\n\nchangesStream.on('data', function(node) {\n  console.log('change:', node)\n})\n```\n\nOptions include:\n\n``` js\n{\n  since: changeNumber     // only returns changes AFTER the number\n  live: false             // never close the change stream\n  tail: false             // since = lastChange\n  valueEncoding: 'binary'\n}\n```\n\n#### `replicationStream = log.replicate([options])`\n\nReplicate the log to another one using a replication stream.\nSimply pipe your replication stream together with another log's replication stream.\n\n``` js\nvar l1 = hyperlog(db1)\nvar l2 = hyperlog(db2)\n\nvar s1 = l1.createReplicationStream()\nvar s2 = l2.createReplicationStream()\n\ns1.pipe(s2).pipe(s1)\n\ns1.on('end', function() {\n  console.log('replication ended')\n})\n```\n\nOptions include:\n\n``` js\n{\n  mode: 'push' | 'pull' | 'sync', // set replication mode. defaults to sync\n  live: true, // keep the replication stream open. defaults to false\n  metadata: someBuffer, // send optional metadata as part of the handshake\n  frame: true // frame the data with length prefixes. defaults to true\n}\n```\n\nIf you send `metadata` it will be emitted as an `metadata` event on the stream.\nA detailed write up on how the graph replicates will be added later.\n\n#### log.on('preadd', function (node) {})\n\nOn the same tick as `log.add()` is called, this event fires with the `node`\nabout to be inserted into the log. At this stage of the add process, node has\nthese properties:\n\n* `node.log`\n* `node.key`\n* `node.value`\n* `node.links`\n\n#### log.on('add', function (node) {})\n\nAfter a node has been successfully added to the log, this event fires with the\nfull `node` object that the callback to `.add()` gets.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "gitHead": "34ee978f2cc6a14a9759890e54f52ecacefd5350",
  "_id": "hyperlog@4.6.0",
  "_shasum": "a4b4d0854d5ccf3c723f0ac39fedda27614c7364",
  "_from": "hyperlog@*"
}
