{
  "name": "mutexify",
  "version": "1.1.0",
  "description": "mutex lock for javascript",
  "main": "index.js",
  "dependencies": {},
  "devDependencies": {
    "tape": "^3.0.2"
  },
  "scripts": {
    "test": "tape test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mafintosh/mutexify.git"
  },
  "author": {
    "name": "Mathias Buus",
    "url": "@mafintosh"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mafintosh/mutexify/issues"
  },
  "keywords": [
    "mutex",
    "lock"
  ],
  "homepage": "https://github.com/mafintosh/mutexify",
  "readme": "# mutexify\n\nBike shed mutex lock implementation in node.js\n\n```\nnpm install mutexify\n```\n\n[![build status](http://img.shields.io/travis/mafintosh/mutexify.svg?style=flat)](http://travis-ci.org/mafintosh/mutexify)\n\nHasn't this been done before? Yes but the specific semantics of this made some of my code simpler\n\n## Usage\n\n\n``` js\nvar mutexify = require('mutexify')\nvar lock = mutexify()\n\nlock(function(release) {\n  console.log('i am now locked')\n  setTimeout(function() {\n    release()\n  }, 1000)\n})\n\nlock(function(release) {\n  console.log('1 second later')\n  release()\n})\n```\n\nA common pattern is to call a callback after you release the lock.\nTo do this in a one-liner pass the callback and the value to `release(cb, err, value)`\n\n``` js\nvar write = function(data, cb) {\n  lock(function(release) {\n    fs.writeFile('locked-file.txt', data, release.bind(null, cb))\n  }) \n}\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "mutexify@1.1.0",
  "_shasum": "bbe017743e544227ee58034cd10f159921f1844d",
  "_resolved": "https://registry.npmjs.org/mutexify/-/mutexify-1.1.0.tgz",
  "_from": "mutexify@>=1.1.0 <2.0.0"
}
